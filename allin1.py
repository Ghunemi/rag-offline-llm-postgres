from pathlib import Path
from llama_cpp import Llama
from langchain_community.utilities import SQLDatabase
from langchain.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableLambda, Runnable
import os
import re

# === CONFIG === #
DB_URI = os.environ.get("DB_URI", "postgresql+psycopg2://g:@localhost:5432/rag_test")
MODEL_PATH = Path("models/mistral-7b-instruct-v0.2.Q4_K_M.gguf")


# === LLM WRAPPER === #
class LocalLLM:
    def __init__(self, model_path: str):
        self.model = Llama(
            model_path=model_path,
            n_ctx=4096,
            n_threads=8,
            n_gpu_layers=20,
            verbose=False
        )

    def __call__(self, prompt: str, max_tokens=256, stop=None) -> str:
        output = self.model(prompt, max_tokens=max_tokens, stop=stop or ["\n\n"])
        return output["choices"][0]["text"].strip()


# === PROMPTS === #
SQL_GENERATION_PROMPT = PromptTemplate.from_template("""
You are an expert SQL developer. Your job is to write PostgreSQL SELECT queries based on a user's natural language question.

## Instructions:
- ONLY generate a valid SQL SELECT query. Do not include comments, explanations, or additional text.
- Use JOINs only when necessary, based on relationships inferred from column names (like `department_id`, `employee_id`, etc.).
- Use LIMIT or ORDER BY only if the question clearly asks for a limited number of results or ordering.
- Pay attention to aggregations (like SUM, COUNT) and filtering logic in the question.
- Semi colons should be only at the end of the SQL statement, if in the middle, it will be wrong.
- Only return a valid SQL SELECT query. Do not return comments, messages, explanations, or markdown formatting.
- If asked about money, show in USD


## Database Schema:
departments(id, name, location)  
employees(id, name, email, department_id, job_title, hired_at)  
projects(id, name, description, department_id, start_date, end_date)  
clients(id, name, industry, contact_email)  
timesheets(id, employee_id, project_id, hours_worked, work_date)  
salaries(employee_id, monthly_salary, currency)  

## Examples:

Q: What is the total salary paid to employees?  
A: SELECT SUM(monthly_salary) FROM salaries;

Q: Which employees work in the IT department?  
A: SELECT e.name FROM employees e JOIN departments d ON e.department_id = d.id WHERE d.name = 'IT';

Q: List the names and emails of all clients in the healthcare industry.  
A: SELECT name, contact_email FROM clients WHERE industry = 'healthcare';
                                                     
Q: list me 2 projects.
A: SELECT p.name, p.description FROM projects p LIMIT 2;

Q: How many hours did each employee work on Project X?  
A: SELECT e.name, SUM(t.hours_worked) FROM timesheets t JOIN employees e ON t.employee_id = e.id JOIN projects p ON t.project_id = p.id ILIKE '%Project X%' GROUP BY e.name;

Q: {question}  
A:
""")


ANSWER_PROMPT = PromptTemplate.from_template("""You are a helpful assistant. Given the user's question and the result of an SQL query, answer in natural language.

Question: {question}
Result: {result}
Answer:""")


# === BUILD RAG PIPELINE === #
def build_rag_chain() -> Runnable:
    db = SQLDatabase.from_uri(DB_URI)
    llm = LocalLLM(str(MODEL_PATH))

    def question_to_sql_fn(inputs):
        prompt = SQL_GENERATION_PROMPT.format(question=inputs["question"])
        #print(f"\n[Prompt Sent to LLM]:\n{prompt}\n")  # DEBUG
        sql = llm(prompt)
        #sql = re.sub(r"```(?:sql)?", "", sql, flags=re.IGNORECASE).strip()
        sql = sql = re.sub(r"```[a-zA-Z0-9]*", "", sql)
        sql = sql.replace("```", "")  # remove any remaining ```
        sql = re.sub(r"--.*", "", sql)  # remove inline SQL comments
        if not sql or len(sql.strip()) == 0:
            print("[Error] Empty SQL generated by LLM.")
            return {"question": inputs["question"], "sql": "SELECT 'Error: Empty SQL'"}
        #print(f"\n[Generated SQL]:\n{sql}\n")  # DEBUG
        return {"question": inputs["question"], "sql": sql}

    def run_sql_fn(inputs):
        sql = inputs["sql"].strip().rstrip(";")
        if not sql.lower().startswith("select") or len(sql) < 10:
            return {"question": inputs["question"], "result": "[SQL Error] Invalid or empty SQL."}
        try:
            result = db.run(sql)
            if isinstance(result, list) and all(isinstance(row, tuple) and len(row) == 1 for row in result):
                result = [row[0] for row in result]
        except Exception as e:
            result = f"[SQL Error] {e}"
        #print(f"[SQL Result]: {result}") 
        return {"question": inputs["question"], "result": result}
    

    def result_to_answer_fn(inputs):
        prompt = ANSWER_PROMPT.format(**inputs)
        answer = llm(prompt)
        return {
            "question": inputs["question"],
            "result": inputs["result"],
            "answer": answer
        }

    def extract_answer(outputs):
        return outputs["answer"]

    return (
        RunnableLambda(question_to_sql_fn)
        | RunnableLambda(run_sql_fn)
        | RunnableLambda(result_to_answer_fn)
        | RunnableLambda(extract_answer)
    )


# === INTERFACE === #
def main():
    print("\U0001F517 Starting RAG system...")
    chain = build_rag_chain()
    print("âœ… Ready. Ask your questions below (type 'exit' to quit):\n")

    while True:
        question = input("You: ")
        if question.lower() in {"exit", "quit"}:
            break
        try:
            answer = chain.invoke({"question": question})
            print(f"\n\U0001F9E0 Answer: {answer}\n")
        except Exception as e:
            print(f"\n[Error] {str(e)}\n")


if __name__ == "__main__":
    main()
 
    # show me 2 projects
    # What is name of the department with id 1?
    # Which employees work in the department 1?
    # What is the total salary paid to employees?
    # list me our clients, but limit on 5
    # How many hours did each employee work on project transition mission-critical solutions?